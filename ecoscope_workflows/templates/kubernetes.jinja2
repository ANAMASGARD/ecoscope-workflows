"""Airflow DAG generated by `ecoscope_workflows/generate_dag.py`"""
from datetime import datetime

from airflow.configuration import conf 
from airflow.decorators import dag, task

from ecoscope_workflows.decorators import distributed

namespace = conf.get("kubernetes", "NAMESPACE")  # does this work?

def import_item(): ...  # TODO: implement in workflows

# TODO: possibly need some global de/serialization fsspec filesystem
# defined here, inheriting system credentials?

{% for t in tasks %}
@task.kubernetes(
    image="{{ t.known_task.operator.image }}",
    in_cluster=True,
    namespace=namespace,
    name="{{ t.known_task.operator.name }}",
    container_resources={{ t.known_task.operator.container_resources }},
    get_logs=True,
    log_events_on_failure=True,
    do_xcom_push=True,
)
def {{ t.known_task_name }}(
    {%- if t.arg_dependencies %}
    {% for arg in t.arg_dependencies %}{{ arg }},{% endfor -%}
    {% endif %}
    params: dict | None = None,  # Airflow DAG Params passed with `--conf` on trigger
):
    {%- if t.arg_dependencies %}
    # deserializers
    {%- for arg in t.arg_dependencies %}
    from ecoscope_workflows.serde import {{ t.arg_prevalidators[arg] }}
    {% endfor %}
    {% else %}
    {% endif -%}

    # the task itself, wrapping it as `distributed`, and fetching its kwargs
    plain_task = import_item("{{ t.known_task.importable_reference }}")
    distributed_task = distributed(plain_task)
    task_kwargs = params["{{ t.known_task_name }}"]
    
    # something about return_postvalidator closures
    serialized_result_uri = distributed_task.replace(
        {%- if t.arg_dependencies %}
        arg_prevalidators={
            {% for arg in t.arg_dependencies %}"{{ arg }}": {{ t.arg_prevalidators[arg] }},{% endfor %}
        },
        {% else %}
        # this task has no arg_dependencies, therefore it does not require arg_prevalidators
        {% endif -%}
        return_postvalidator=...,  # set this from a storage config
        validate=True
    )(
        {%- if t.arg_dependencies %}
        {% for arg in t.arg_dependencies %}{{ arg }}={{ arg }},{% endfor -%}
        {% endif %}
        **task_kwargs,
    )
    return serialized_result_uri

{% endfor %}


@dag(schedule="@daily", start_date=datetime(2021, 12, 1), catchup=False)
def {{ name }}():
    # FIXME: first pass assumes tasks are already in topological order
    {% for t in tasks %}
    {{ t.known_task_name }}_return = {{ t.known_task_name }}(
    {%- if t.arg_dependencies %}
        {% for arg in t.arg_dependencies %}{{ arg }}={{ t.arg_dependencies[arg] }},{% endfor %}
    )
    {% else %})
    {% endif -%}
    {% endfor -%}

